Introduccion:

DP -> Enhanced recursion
Recursion seria como el padre de DP. se usa para guardar estados que se repiten en las llamadas de recursion.

Identificar un problema DP:
DP = enhanced recursion
Eso quiere decir que todos los problemas que requieren recursion se pueden hacer con DP.

DP siempre pide una solucino optima.
Hay un sentido de eleccion que tomar o que no -> Siempre que una funcion haga 2 llamadas recursivas hay probabilidad de Dp

Resolver Problema:
1. Carajo, haz primero la definicio recursiva antes de siquiera empezar a tabular
2. Aplicarle memorizacion que es agregar como 2 lineas de codigo
3. Top_down o Tabulation


Problemas Padre:

Knapsack: De este hay 3 tipos de knapsack

1. Fractional Knapsack -> Greedy no Dp  (Aqui se pueden partir los items en partes para meterlos al saco con su valor cortado tmb)

2. 0/1 KnapSack (El 0-1 se refiere a que bien tomamos un item o no) 

3. Unbounded Knapsack  (Es como tener un almacen en donde puedo meter a la bolsa un mismo onjeto varias veces)

	0/1 KnapSack

	Este problema trata de una mochila que se llama knapsack
	Input    : I1 I2 I3 I4 ... -> Choice
	weights[]:  1  3  4  5 ...
	values[] :  1  4  5  7 ...

	Wcapacity:  7

	Output   : Maximum Profit  -> Optimal

	Tenemos choice y optimal -> Dp problem

	Plantear recursion -> Memoize -> Dp = recursion + storage: 

	Plantear Recursion:
		Identificando Base_Conditions:
			Caso n == 0 || Wcapacity == 0 --> return 0;
		Recursion: 
			Priorizar que la recursion llame a un input reducido

	Resultado: 

	int knapSack_firstApproach(int w[], int v[], int C, int n){
	    if(n == 0 || C == 0) return 0;

	    if(w[n-1] <= C) 
	    	return max(v[n-1] + knapSack_firstApproach(w,v,C-w[n-1],n-1),
	    			knapSack_firstApproach(w,v,C,n-1));
	    else
	    	return knapSack_firstApproach(w, v, C, n-1);
	}

	Memoize - Top-Down:
	Se suele cometer el error de partir de una tabla  que representaria la memo y despues de un analisis obtener el algoritmo DP. Pero es mas facil partir de un algoritmo recursivo que resuelva el problema y aplicar memoization.
	Casi siempre se agregan 2 a 4 lineas de codigo para acceder a una coord de la memo en donde guardar o recuperar un estado.
	Esto es el DP;

	Cuando la recursion es sencilla o solo tiene una llamada generalmente no se usa DP. Aunque, es bastante util al momento que hay +2 llamadas recursivas x el hecho de repetir o sobreponer estados.
	Pasos: 
		1. Identificar aquellos valores que daran sentido a nuestras coordenadas:
			Busca aquellos valores que cambian en cada llamada recursiva, ya se aumenten o disminuyan.
			En el ejemplo: 
			+---+----+-----------+
			| C | -> | C-w[n-1]  |
			+---+----+-----------+
			| n | -> | n-1       |
			+---+----+-----------+
		2. Describimos el array y la definicion de los indices.
			En el ejemplo:
			int dp[n+1][w+1];
			Preferible inicializarlo con -1 o 0 dependiendo
			n + 1 -> para separar el caso de n==0 -> return 0;
			w + 1 -> para separar el caso de w==0 -> return 0;

		3. Adaptar el codigo:
			int dp[102][1002];   // constraints: n<=100 && w<=1000;
			memset(dp,-1,sizeof(dp));

			int knapSack_dp(int w[], int v[], int C, int n){
			    if(n == 0 || C == 0) return 0;

			    if(dp[n][C] != -1) 
			    	return dp[n][C];

			    if(w[n-1] <= C) 
			    	return dp[n][w] = max(v[n-1] + knapSack_dp(w,v,C-w[n-1],n-1),
			    			knapSack_dp(w,v,C,n-1));
			    else
			    	return dp[n][w] = knapSack_dp(w, v, C, n-1);

			    return dp[n][C];
			}





Normalmente en problemas del estilo Divide-Conquer se divide un PROBLEMA en SUBPROBLEMAS mas pequeños. Sin embargo, puede darse el caso que varios de estos SUBPROBLEMAS se SOBREPONGAN entre si. Es decir, que se repita un mismo subproblema.

La programacion dinamica y su estilo de memorizacion ayuda que no se vuelvan a calcular estos subproblemas repetidos.

El termino "programacion" tienen una connotacion de un "metodo tabular" mas que codigo en si.

Generalmente su uso es para problemas en donde se OPTIMIZACION para aquellos problemas en donde hay multiples soluciones pero se requiere el MAXIMO o MINIMO valor. 


Pasos Generales:

1. Caracterizar la estructura de una solución óptima.
2. Definir recursivamente el valor de una solución óptima.
3. Calcular el valor de una solución óptima, normalmente de forma ascendente.
4. Construir una solución óptima a partir de la información calculada.


EJEMPLOS:

ROD_CUTTING

Imaginemos que tenemos un tronco de longitud L y una lista de precios en las que se vende un tronco de longitud i a un precio pi x ejemplo:

i:  |  1  |  2  |  3  |  4  |  5  |  6  |  7  |  8  |  9  | 10  |
pi: |  1  |  5  |  8  |  9  | 10  | 17  | 18  | 20  | 24  | 30  |


Como se puede observar hay multiples formas de cortar el labor: 2^(n - 1) para un arbol de longitud n.

Pasos:
1. Caracterizar la estructura de una solución óptima:

Primero definimos que nuestra solucion va a denotar una notacion aditiva. 
Talque para un n = 7 una de las soluciones puede definirse como: 
7 = 2 + 2 + 3
partes cortadas: 3

Entonces para una solucion optima observamos que 
si corta el arbol en k partes:
n   = i_1 + i_2 + i_3 + ... + i_k

y su valor esta denotado por:
r_n = p_1 + p_2 + p_3 + ... + p_k

Analizamos para i = 1, 2 , 3, .. 10

r_0 = 0 no tronco gaaaa
r_1 = 1                              -> no se pueden hacer mas cortes
r_2 = max(5, r_1 + r_1) = 5          -> no se hacen cortes ya que 2 < 5
r_3 = max(8, r_1 + r_2) = 8          -> no se hacen cortes ya que 5 + 1 < 8
r_4 = max(9, r_1 + r_3, r_2 + r_2) = 10 -> 4 = 2 + 2
r_5 = max(10, r_1 + r_4, r_2 + r_3) = 13 -> 5 = 2 + 3
r_6 = max(17, r_1 + r_5, r_2 + r_4, r_3 + r_3) = 17 -> no cortes
r_7 = max(18, r_1 + r_6, ... ) 18 -> 7 = 1 + 6 || 7 = 2 + 2 + 3
r_8 = 22 -> 8 = 2 + 6
r_9 = 25 -> 9 = 3 + 6
r_10 = 30 -> no cortes

r_n = max(p_n, r_1 + r_(n-1), r_2 + r_(n-2), ..., r_(n-1) + r_1);

for i = 1 -> n
V = max(V, p_i + r_(n-i));

#include <bits/stdc++.h>
using namespace std;

int r[1000] {};

int memorized_rod_cut(int p[], int n){
    int q=0;
    for(int j=1; j<=n; j++){
        q = 0;
        for(int i=1; i<=j; i++){
            q = max(q, p[i-1] + r[j - i]);
        }
        r[j] = q;
    }
    return r[n];
}

int rod_cut(int arreglo[], int maxData){
    if(maxData <= 0) return 0;

    int maxValue = 0;
    for (int i = 0; i < maxData; i++)
    {
        maxValue = max(maxValue, arreglo[i] + rod_cut(arreglo, maxData - i - 1));
    }
    return maxValue;    
}

int main(){
    //         1  2  3  4   5   6   7   8   9  10
    int p[10] {1, 5, 8, 9, 10, 17, 18, 20, 24, 30};

    for (int i = 1; i <= 10; i++)
    {
        cout << rod_cut(p, i) << "  ";
    }
    cout << endl;
    

    for (int i = 1; i <= 10; i++)
    {
        cout << memorized_rod_cut(p, i) << "  ";
    }
    cout << endl;
    
    return 0;
}